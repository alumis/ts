/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../ts-async/CancellationToken.ts":
/*!*******************************************!*\
  !*** ../../ts-async/CancellationToken.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CancellationToken\": () => (/* binding */ CancellationToken),\n/* harmony export */   \"CancellationTokenNone\": () => (/* binding */ CancellationTokenNone),\n/* harmony export */   \"LinkedCancellationToken\": () => (/* binding */ LinkedCancellationToken)\n/* harmony export */ });\n/* harmony import */ var _OperationCancelledError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OperationCancelledError */ \"../../ts-async/OperationCancelledError.ts\");\n\nclass CancellationToken {\n  listeners = new Set();\n\n  addListener(listener) {\n    if (this.isCancellationRequested) listener();else this.listeners.add(listener);\n  }\n\n  cancel() {\n    if (!this.isCancellationRequested) {\n      this.isCancellationRequested = true;\n\n      for (var f of this.listeners) f();\n\n      delete this.listeners;\n    }\n  }\n\n  removeListener(listener) {\n    if (this.listeners) this.listeners.delete(listener);\n  }\n\n  link(token) {\n    return new LinkedCancellationToken([this, token]);\n  }\n\n  throwIfCancellationRequested() {\n    if (this.isCancellationRequested) throw new _OperationCancelledError__WEBPACK_IMPORTED_MODULE_0__.OperationCancelledError();\n  }\n\n}\nclass CancellationTokenNone extends CancellationToken {\n  addListener(_listener) {}\n\n  removeListener(_listener) {}\n\n  cancel() {\n    throw new Error();\n  }\n\n  static get singleton() {\n    return CancellationTokenNone._singleton || (CancellationTokenNone._singleton = new CancellationTokenNone());\n  }\n\n}\nclass LinkedCancellationToken extends CancellationToken {\n  constructor(tokens) {\n    super();\n    this.tokens = tokens;\n    this.cancel = this.cancel.bind(this);\n\n    for (let t of tokens) t.addListener(this.cancel);\n  }\n\n  dispose() {\n    for (var t of this.tokens) t.removeListener(this.cancel);\n  }\n\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-async/CancellationToken.ts?");

/***/ }),

/***/ "../../ts-async/OperationCancelledError.ts":
/*!*************************************************!*\
  !*** ../../ts-async/OperationCancelledError.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OperationCancelledError\": () => (/* binding */ OperationCancelledError)\n/* harmony export */ });\nclass OperationCancelledError extends Error {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Operation was cancelled\";\n    super(message);\n  }\n\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-async/OperationCancelledError.ts?");

/***/ }),

/***/ "../JSX.ts":
/*!*****************!*\
  !*** ../JSX.ts ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalPropertyHandlers\": () => (/* binding */ globalPropertyHandlers),\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"createNode\": () => (/* binding */ createNode),\n/* harmony export */   \"appendChild\": () => (/* binding */ appendChild),\n/* harmony export */   \"CONNECT_CALLBACKS_KEY\": () => (/* binding */ CONNECT_CALLBACKS_KEY),\n/* harmony export */   \"appendConnectCallbackToNode\": () => (/* binding */ appendConnectCallbackToNode),\n/* harmony export */   \"DISCONNECT_CALLBACKS_KEY\": () => (/* binding */ DISCONNECT_CALLBACKS_KEY),\n/* harmony export */   \"appendDisconnectCallbackToNode\": () => (/* binding */ appendDisconnectCallbackToNode),\n/* harmony export */   \"disconnectNode\": () => (/* binding */ disconnectNode),\n/* harmony export */   \"connectNode\": () => (/* binding */ connectNode),\n/* harmony export */   \"bindProperties\": () => (/* binding */ bindProperties),\n/* harmony export */   \"bindProperty\": () => (/* binding */ bindProperty),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass),\n/* harmony export */   \"switchClass\": () => (/* binding */ switchClass),\n/* harmony export */   \"bindStyle\": () => (/* binding */ bindStyle),\n/* harmony export */   \"replaceChildNodesWithDocumentFragment\": () => (/* binding */ replaceChildNodesWithDocumentFragment)\n/* harmony export */ });\n/* harmony import */ var _alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @alumis/ts-observables/ComputedObservable */ \"../../ts-observables/ComputedObservable.ts\");\n/* harmony import */ var _alumis_ts_observables_ModifiableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alumis/ts-observables/ModifiableObservable */ \"../../ts-observables/ModifiableObservable.ts\");\n/* harmony import */ var _alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @alumis/ts-observables/isObservable */ \"../../ts-observables/isObservable.ts\");\n/* harmony import */ var _alumis_ts_observables_ObservableList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @alumis/ts-observables/ObservableList */ \"../../ts-observables/ObservableList.ts\");\n\n\n\n\nconst globalPropertyHandlers = new Map();\nclass Component {\n  onDisconnect() {}\n\n}\nfunction createNode(element, properties) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  if (typeof element === \"string\") return createHTMLElementFromTagName(element, properties, children);\n  if (typeof element === \"function\") return createNodeFromFunction(element, properties, children);\n  if (element === null) return createDocumentFragment(children);\n  throw new Error(`Unable to create element of type '${typeof element}'`);\n}\n\nfunction createHTMLElementFromTagName(tagName, properties, children) {\n  let element = document.createElement(tagName);\n\n  for (let c of children) appendChild(element, c);\n\n  if (properties) bindProperties(element, properties);\n  return element;\n}\n\nfunction appendChild(parentNode, child) {\n  if (child instanceof HTMLElement || child instanceof SVGElement || child instanceof Comment || child instanceof DocumentFragment) parentNode.appendChild(child);else if (child instanceof Component) appendComponentChild(parentNode, child);else if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(child)) appendObservableChild(parentNode, child);else if (typeof child === \"function\") appendObservableExpressionChild(parentNode, child);else if (child instanceof _alumis_ts_observables_ObservableList__WEBPACK_IMPORTED_MODULE_3__.ObservableList) appendObservableListChild(parentNode, child);else if (child instanceof Array) for (let c of child) appendChild(parentNode, c);else if (child !== null && child !== undefined) parentNode.appendChild(document.createTextNode(child));\n}\n\nfunction appendComponentChild(parentNode, component) {\n  // TODO: Reuse text node\n  let head = document.createComment(` ${component.constructor.name} `),\n      documentFragment = document.createDocumentFragment(),\n      tail = document.createComment(` /${component.constructor.name} `);\n  documentFragment.appendChild(head);\n  documentFragment.appendChild(tail);\n  parentNode.appendChild(documentFragment);\n\n  function set(n) {\n    appendChild(documentFragment, n);\n\n    for (let child = head.nextSibling; child !== tail;) {\n      let n = child;\n      child = child.nextSibling;\n      n.remove();\n    }\n\n    tail.parentNode.insertBefore(documentFragment, tail);\n  }\n\n  function onConnect() {\n    set(component.render());\n    appendDisconnectCallbackToNode(tail, component.onDisconnect.bind(component));\n  }\n\n  appendConnectCallbackToNode(tail, onConnect);\n}\n\nfunction appendObservableChild(parentNode, observable) {\n  let head = document.createComment(\" head \"),\n      documentFragment = document.createDocumentFragment(),\n      tail = document.createComment(\" tail \");\n  documentFragment.appendChild(head);\n  documentFragment.appendChild(tail);\n  parentNode.appendChild(documentFragment);\n\n  function set(n) {\n    if (typeof n === \"string\") {\n      let nextSibling = head.nextSibling;\n\n      if (nextSibling instanceof Text && nextSibling.nextSibling === tail) {\n        nextSibling.textContent = n;\n        return;\n      }\n    }\n\n    appendChild(documentFragment, n);\n\n    for (let child = head.nextSibling; child !== tail;) {\n      let n = child;\n      child = child.nextSibling;\n      n.remove();\n    }\n\n    tail.parentNode.insertBefore(documentFragment, tail);\n  }\n\n  function onConnect() {\n    set(observable.peek());\n    appendDisconnectCallbackToNode(tail, observable.subscribeSneakInLine(set).dispose);\n  }\n\n  appendConnectCallbackToNode(tail, onConnect);\n}\n\nfunction appendObservableExpressionChild(parentNode, observableExpression) {\n  // TODO: Reuse text node\n  let head = document.createComment(\" head \"),\n      documentFragment = document.createDocumentFragment(),\n      tail = document.createComment(\" tail \");\n  documentFragment.appendChild(head);\n  documentFragment.appendChild(tail);\n  parentNode.appendChild(documentFragment);\n\n  function set(n) {\n    if (typeof n === \"string\") {\n      let nextSibling = head.nextSibling;\n\n      if (nextSibling instanceof Text && nextSibling.nextSibling === tail) {\n        nextSibling.textContent = n;\n        return;\n      }\n    }\n\n    appendChild(documentFragment, n);\n\n    for (let child = head.nextSibling; child !== tail;) {\n      let n = child;\n      child = child.nextSibling;\n      n.remove();\n    }\n\n    tail.parentNode.insertBefore(documentFragment, tail);\n  }\n\n  function onConnect() {\n    let observable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(observableExpression);\n    set(observable.peek());\n    observable.subscribeSneakInLine(set);\n    appendDisconnectCallbackToNode(tail, observable.dispose);\n  }\n\n  appendConnectCallbackToNode(tail, onConnect);\n}\n\nconst CONNECT_CALLBACKS_KEY = \"__connectCallbacks\";\nfunction appendConnectCallbackToNode(node, connect) {\n  let connectCallbacks = node[CONNECT_CALLBACKS_KEY];\n  if (connectCallbacks) connectCallbacks.push(connect);else node[CONNECT_CALLBACKS_KEY] = [connect];\n}\nconst DISCONNECT_CALLBACKS_KEY = \"__disconnectCallbacks\";\nfunction appendDisconnectCallbackToNode(node, disconnect) {\n  let disconnectCallbacks = node[DISCONNECT_CALLBACKS_KEY];\n  if (disconnectCallbacks) disconnectCallbacks.push(disconnect);else node[DISCONNECT_CALLBACKS_KEY] = [disconnect];\n}\nfunction disconnectNode(node) {\n  if (node.childNodes.length) {\n    // Depth first, post-order tree traversal\n    for (let child = node.lastChild;;) {\n      disconnectNode(child);\n      if (!(child = child.previousSibling)) break;\n    }\n  }\n\n  let disconnectCallbacks = node[DISCONNECT_CALLBACKS_KEY];\n\n  if (disconnectCallbacks) {\n    node[DISCONNECT_CALLBACKS_KEY] = undefined;\n\n    for (let i = disconnectCallbacks.length; 0 < i;) disconnectCallbacks[--i]();\n  }\n}\nfunction connectNode(node) {\n  let connectCallbacks = node[CONNECT_CALLBACKS_KEY];\n\n  if (connectCallbacks) {\n    for (let i = 0; i < connectCallbacks.length; ++i) connectCallbacks[i]();\n  }\n\n  if (node.childNodes.length) {\n    for (let child = node.firstChild;;) {\n      connectNode(child);\n      if (!(child = child.nextSibling)) break;\n    }\n  }\n}\n\nfunction appendObservableListChild(parentNode, observableList) {\n  let head = document.createComment(\" ObservableList \"),\n      documentFragment = document.createDocumentFragment(),\n      tail = document.createComment(\" /ObservableList \");\n  documentFragment.appendChild(head);\n  documentFragment.appendChild(tail);\n  parentNode.appendChild(documentFragment);\n\n  function onConnect() {\n    for (let child = head.nextSibling; child !== tail;) {\n      let n = child;\n      child = child.nextSibling;\n      n.remove();\n    }\n\n    let items = new Map(),\n        n = null;\n\n    for (let node = observableList.head.next; node !== observableList.tail; node = node.next) {\n      appendChild(documentFragment, node.item);\n      let item = {\n        firstChild: n ? n.nextSibling : documentFragment.firstChild,\n        lastChild: n = documentFragment.lastChild\n      };\n      items.set(node.item, item);\n    }\n\n    tail.parentNode.insertBefore(documentFragment, tail);\n    let subscription = observableList.subscribeSneakInLine(modifications => {\n      for (let m of modifications) {\n        switch (m.type) {\n          case _alumis_ts_observables_ObservableList__WEBPACK_IMPORTED_MODULE_3__.ObservableListModificationType.Append:\n            {\n              let item = items.get(m.item);\n\n              if (item) {\n                if (item.lastChild.nextSibling === tail) break;\n\n                for (let node = item.firstChild;;) {\n                  if (node === item.lastChild) {\n                    documentFragment.appendChild(node);\n                    break;\n                  }\n\n                  let n = node;\n                  node = node.nextSibling;\n                  documentFragment.appendChild(n);\n                }\n              } else {\n                appendChild(documentFragment, m.item);\n                items.set(m.item, {\n                  firstChild: documentFragment.firstChild,\n                  lastChild: documentFragment.lastChild\n                });\n              }\n\n              tail.parentNode.insertBefore(documentFragment, tail);\n              break;\n            }\n\n          case _alumis_ts_observables_ObservableList__WEBPACK_IMPORTED_MODULE_3__.ObservableListModificationType.InsertBefore:\n            {\n              let item = items.get(m.item);\n\n              if (item) {\n                for (let node = item.firstChild;;) {\n                  if (node === item.lastChild) {\n                    documentFragment.appendChild(node);\n                    break;\n                  } else {\n                    let n = node;\n                    node = node.nextSibling;\n                    documentFragment.appendChild(n);\n                  }\n                }\n              } else {\n                appendChild(documentFragment, m.item);\n                item = {\n                  firstChild: documentFragment.firstChild,\n                  lastChild: documentFragment.lastChild\n                };\n                items.set(m.item, item);\n              }\n\n              tail.parentNode.insertBefore(documentFragment, m.refItem ? items.get(m.refItem).firstChild : tail);\n              break;\n            }\n\n          case _alumis_ts_observables_ObservableList__WEBPACK_IMPORTED_MODULE_3__.ObservableListModificationType.Remove:\n            {\n              let item = items.get(m.item);\n              items.delete(m.item);\n\n              for (let node = item.firstChild;;) {\n                if (node === item.lastChild) {\n                  node.remove();\n                  break;\n                }\n\n                let n = node;\n                node = node.nextSibling;\n                n.remove();\n              }\n\n              break;\n            }\n        }\n      }\n    });\n    appendDisconnectCallbackToNode(tail, subscription.dispose);\n  }\n\n  appendConnectCallbackToNode(tail, onConnect);\n}\n\nfunction bindProperties(node, properties) {\n  for (let n in properties) {\n    let value = properties[n],\n        globalPropertyHandler = globalPropertyHandlers.get(n);\n    if (globalPropertyHandler) globalPropertyHandler(node, value, properties);else if (n.startsWith(\"on\") && 2 < n.length) node[n] = value;else bindProperty(node, n, value);\n  }\n}\nfunction bindProperty(element, name, expression) {\n  if (name.indexOf(\"-\") !== -1) {\n    if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(expression)) {\n      appendConnectCallbackToNode(element, () => {\n        let subscription = expression.subscribeInvokeSneakInLine(n => {\n          element.setAttribute(name, n);\n        });\n        appendDisconnectCallbackToNode(element, subscription.dispose);\n      });\n    } else if (typeof expression === \"function\") {\n      appendConnectCallbackToNode(element, () => {\n        let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(expression);\n        computedObservable.subscribeInvokeSneakInLine(n => {\n          element.setAttribute(name, n);\n        });\n        appendDisconnectCallbackToNode(element, computedObservable.dispose);\n      });\n    } else element.setAttribute(name, expression);\n  } else {\n    if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(expression)) {\n      appendConnectCallbackToNode(element, () => {\n        let subscription = expression.subscribeInvokeSneakInLine(n => {\n          element[name] = n;\n        });\n        appendDisconnectCallbackToNode(element, subscription.dispose);\n\n        if (expression instanceof _alumis_ts_observables_ModifiableObservable__WEBPACK_IMPORTED_MODULE_1__.ModifiableObservable) {\n          switch (name) {\n            case \"value\":\n            case \"valueAsDate\":\n            case \"valueAsNumber\":\n              {\n                let listener = _e => {\n                  expression.setValueDontNotifySubscription(element[name], subscription);\n                };\n\n                switch (element.tagName) {\n                  case \"INPUT\":\n                  case \"TEXTAREA\":\n                    element.addEventListener(\"input\", listener);\n                    appendDisconnectCallbackToNode(element, () => {\n                      element.removeEventListener(\"input\", listener);\n                    });\n                    break;\n\n                  case \"SELECT\":\n                    element.addEventListener(\"change\", listener);\n                    appendDisconnectCallbackToNode(element, () => {\n                      element.removeEventListener(\"change\", listener);\n                    });\n                    break;\n                }\n\n                break;\n              }\n\n            case \"checked\":\n              {\n                let listener = _e => {\n                  expression.setValueDontNotifySubscription(element.checked, subscription);\n                };\n\n                element.addEventListener(\"change\", listener);\n                appendDisconnectCallbackToNode(element, () => {\n                  element.removeEventListener(\"change\", listener);\n                });\n                break;\n              }\n          }\n        }\n      });\n    } else if (typeof expression === \"function\") {\n      appendConnectCallbackToNode(element, () => {\n        let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(expression);\n        computedObservable.subscribeInvokeSneakInLine(n => {\n          element[name] = n;\n        });\n        appendDisconnectCallbackToNode(element, computedObservable.dispose);\n      });\n    } else element[name] = expression;\n  }\n}\nglobalPropertyHandlers.set(\"role\", (node, value) => {\n  if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(value)) {\n    appendConnectCallbackToNode(node, () => {\n      let subscription = value.subscribeInvokeSneakInLine(n => {\n        node.setAttribute(\"role\", n);\n      });\n      appendDisconnectCallbackToNode(node, subscription.dispose);\n    });\n  } else if (typeof value === \"function\") {\n    appendConnectCallbackToNode(node, () => {\n      let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(value);\n      computedObservable.subscribeInvokeSneakInLine(n => {\n        node.setAttribute(\"role\", n);\n      });\n      appendDisconnectCallbackToNode(node, computedObservable.dispose);\n    });\n  } else node.setAttribute(\"role\", value);\n});\nfunction toggleClass(node, value) {\n  appendConnectCallbackToNode(node, () => {\n    for (let p in value) {\n      let expression = value[p];\n\n      if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(expression)) {\n        let subscription = function (p) {\n          return expression.subscribeInvokeSneakInLine(n => {\n            node.classList.toggle(p, n);\n          });\n        }(p);\n\n        appendDisconnectCallbackToNode(node, subscription.dispose);\n      } else if (typeof expression === \"function\") {\n        let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(expression);\n\n        (function (p) {\n          computedObservable.subscribeInvokeSneakInLine(n => {\n            node.classList.toggle(p, n);\n          });\n        })(p);\n\n        appendDisconnectCallbackToNode(node, computedObservable.dispose);\n      } else node.classList.toggle(p, !!expression);\n    }\n  });\n}\nglobalPropertyHandlers.set(\"toggle\", toggleClass);\nfunction switchClass(node, value) {\n  if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(value)) {\n    appendConnectCallbackToNode(node, () => {\n      let subscription = value.subscribeInvokeSneakInLine(n => {\n        node.className = n;\n      });\n      appendDisconnectCallbackToNode(node, subscription.dispose);\n    });\n  } else if (typeof value === \"function\") {\n    appendConnectCallbackToNode(node, () => {\n      let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(value);\n      computedObservable.subscribeInvokeSneakInLine(n => {\n        node.className = n;\n      });\n      appendDisconnectCallbackToNode(node, computedObservable.dispose);\n    });\n  } else {\n    appendConnectCallbackToNode(node, () => {\n      for (let i of value) {\n        if (typeof i === \"string\") node.classList.add(i);else if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(i)) {\n          let subscription = i.subscribeInvokeSneakInLine((n, o) => {\n            if (o) node.classList.remove(o);\n            if (n) node.classList.add(n);\n          });\n          appendDisconnectCallbackToNode(node, subscription.dispose);\n        } else {\n          let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(i);\n          computedObservable.subscribeInvokeSneakInLine((n, o) => {\n            if (o) node.classList.remove(o);\n            if (n) node.classList.add(n);\n          });\n          appendDisconnectCallbackToNode(node, computedObservable.dispose);\n        }\n      }\n    });\n  }\n}\nglobalPropertyHandlers.set(\"switch\", switchClass);\nfunction bindStyle(element, value) {\n  appendConnectCallbackToNode(element, () => {\n    for (let p in value) {\n      let v = value[p];\n      if (typeof v === \"string\") element.style[p] = v;else if ((0,_alumis_ts_observables_isObservable__WEBPACK_IMPORTED_MODULE_2__.isObservable)(v)) {\n        let subscription = v.subscribeInvokeSneakInLine(n => {\n          element.style[p] = n;\n        });\n        appendDisconnectCallbackToNode(element, subscription.dispose);\n      } else {\n        let computedObservable = (0,_alumis_ts_observables_ComputedObservable__WEBPACK_IMPORTED_MODULE_0__.co)(v);\n        computedObservable.subscribeInvokeSneakInLine(n => {\n          element.style[p] = n;\n        });\n        appendDisconnectCallbackToNode(element, computedObservable.dispose);\n      }\n    }\n  });\n}\nglobalPropertyHandlers.set(\"style\", bindStyle);\n\nfunction createNodeFromFunction(fn, properties, children) {\n  if (fn.prototype instanceof Component) return new fn(properties, children);else return fn(properties, children);\n}\n\nfunction createDocumentFragment(children) {\n  let documentFragment = document.createDocumentFragment();\n\n  for (let c of children) appendChild(documentFragment, c);\n\n  return documentFragment;\n}\n\nfunction replaceChildNodesWithDocumentFragment(parentNode, documentFragment) {\n  let oldChildNodes = document.createDocumentFragment(),\n      firstChild;\n\n  while (firstChild = parentNode.firstChild) oldChildNodes.appendChild(firstChild);\n\n  parentNode.appendChild(documentFragment);\n  return oldChildNodes;\n}\nconst bodyMutationObserver = new MutationObserver(function (mutations, observer) {\n  for (let m of mutations) {\n    for (let n of m.removedNodes) disconnectNode(n);\n\n    for (let n of m.addedNodes) connectNode(n);\n  }\n});\nbodyMutationObserver.observe(document.body, {\n  subtree: true,\n  childList: true\n});\n\n//# sourceURL=webpack://test-workspace/../JSX.ts?");

/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @alumis/ts-jsx/JSX */ \"../JSX.ts\");\n/* harmony import */ var _alumis_ts_observables_ModifiableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alumis/ts-observables/ModifiableObservable */ \"../../ts-observables/ModifiableObservable.ts\");\n\n\n\nlet bool1 = (0,_alumis_ts_observables_ModifiableObservable__WEBPACK_IMPORTED_MODULE_1__.o)(true);\nlet bool2 = (0,_alumis_ts_observables_ModifiableObservable__WEBPACK_IMPORTED_MODULE_1__.o)(\"true\");\n\nclass TestComponent extends _alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    return (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(null, null, (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"div\", null, \"Dette er en test\"), (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"div\", null, \"Dette er en test2 \", bool2), (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"div\", null, \"Dette er en test3 \", bool1));\n  }\n\n}\n\ndocument.body.appendChild((0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(null, null, (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"div\", null, \"Hello, world!\"), (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"button\", {\n  type: \"button\",\n  onclick: () => bool1.value = !bool1.peek()\n}, \"Value: \", bool1), () => bool1.value ? (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"button\", {\n  type: \"button\",\n  onclick: () => bool2.value = bool2.peek() === \"true\" ? \"false\" : \"true\"\n}, \"Value: \", bool2) : null, (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(TestFunction, null), (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(TestComponent, null), (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"p\", null, \"Foo\")));\n\nfunction TestFunction() {\n  return (0,_alumis_ts_jsx_JSX__WEBPACK_IMPORTED_MODULE_0__.createNode)(\"p\", null, \"Test function \", bool2);\n}\n\n//# sourceURL=webpack://test-workspace/./src/index.tsx?");

/***/ }),

/***/ "../../ts-observables/AsyncObservable.ts":
/*!***********************************************!*\
  !*** ../../ts-observables/AsyncObservable.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsyncObservable\": () => (/* binding */ AsyncObservable)\n/* harmony export */ });\n/* harmony import */ var _alumis_ts_async_CancellationToken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @alumis/ts-async/CancellationToken */ \"../../ts-async/CancellationToken.ts\");\n/* harmony import */ var _alumis_ts_async_OperationCancelledError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alumis/ts-async/OperationCancelledError */ \"../../ts-async/OperationCancelledError.ts\");\n/* harmony import */ var _ComputedObservable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ComputedObservable */ \"../../ts-observables/ComputedObservable.ts\");\n/* harmony import */ var _ModifiableObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ModifiableObservable */ \"../../ts-observables/ModifiableObservable.ts\");\n\n\n\n\nclass AsyncObservable {\n  constructor(loadAsyncFn) {\n    this.loadAsyncFn = loadAsyncFn;\n  }\n\n  ensureLoadFinishedAsync() {\n    if (this._loadFinished) return Promise.resolve();\n    if (this._loadPromise) return this._loadPromise;\n    let cancellationToken = new _alumis_ts_async_CancellationToken__WEBPACK_IMPORTED_MODULE_0__.CancellationToken();\n    this._cancellationToken = cancellationToken;\n    let releaseSemaphore,\n        semaphore = new Promise(r => {\n      releaseSemaphore = r;\n    });\n\n    let loadPromise = (async () => {\n      await semaphore;\n\n      for (;;) {\n        try {\n          var value = await this.loadAsyncFn(cancellationToken);\n\n          if (cancellationToken.isCancellationRequested) {\n            if (this._loadPromise === loadPromise) {\n              this._cancellationToken = cancellationToken = new _alumis_ts_async_CancellationToken__WEBPACK_IMPORTED_MODULE_0__.CancellationToken();\n              continue;\n            } else throw new _alumis_ts_async_OperationCancelledError__WEBPACK_IMPORTED_MODULE_1__.OperationCancelledError();\n          }\n        } catch (e) {\n          if (this._loadPromise === loadPromise) {\n            this._loadFinished = true;\n            this._loadPromise = null;\n            this._cancellationToken = null;\n            this._state.value = {\n              error: {\n                error: e\n              }\n            };\n          }\n\n          return;\n        }\n\n        if (this._loadPromise === loadPromise) {\n          this._loadFinished = true;\n          this._loadPromise = null;\n          this._cancellationToken = null;\n          this._state.value = {\n            value\n          };\n        }\n\n        return;\n      }\n    })();\n\n    this._loadPromise = loadPromise;\n    releaseSemaphore();\n    return loadPromise;\n  }\n\n  _state = (0,_ModifiableObservable__WEBPACK_IMPORTED_MODULE_3__.o)();\n  _computedValue = (0,_ComputedObservable__WEBPACK_IMPORTED_MODULE_2__.co)(() => {\n    let value = this._state.value;\n    if (!value) return undefined;\n    if (value.error) throw value.error.error;\n    return value.value;\n  });\n\n  get value() {\n    return this._computedValue.value;\n  }\n\n  peek() {\n    return this._computedValue.peek();\n  }\n\n  subscribe(callback) {\n    return this._computedValue.subscribe(callback);\n  }\n\n  subscribeSneakInLine(callback) {\n    return this._computedValue.subscribeSneakInLine(callback);\n  }\n\n  subscribeInvoke(callback) {\n    return this._computedValue.subscribeInvoke(callback);\n  }\n\n  subscribeInvokeSneakInLine(callback) {\n    return this._computedValue.subscribeInvokeSneakInLine(callback);\n  }\n\n  invalidate() {\n    this._computedValue.invalidate();\n  }\n\n  cancelGracefully() {\n    if (this._loadPromise) {\n      let cancellationToken = this._cancellationToken;\n      this._loadPromise = null;\n      this._cancellationToken = null;\n      cancellationToken.cancel();\n    }\n  }\n\n  dispose() {\n    this.cancelGracefully();\n\n    this._computedValue.dispose();\n\n    this._state.dispose();\n  }\n\n  restartIfLoadIsOngoingOrFinished() {\n    this._state.value = null;\n    if (this._loadPromise) this._cancellationToken.cancel();else if (this._loadFinished) {\n      this._loadFinished = false;\n      this.ensureLoadFinishedAsync();\n    }\n  }\n\n  update(loadAsyncFn) {\n    if (this.loadAsyncFn !== loadAsyncFn) {\n      this.loadAsyncFn = loadAsyncFn;\n      this._state.value = null;\n      if (this._loadPromise) this._cancellationToken.cancel();else if (this._loadFinished) {\n        this._loadFinished = false;\n        this.ensureLoadFinishedAsync();\n      }\n    }\n  }\n\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/AsyncObservable.ts?");

/***/ }),

/***/ "../../ts-observables/ComputedObservable.ts":
/*!**************************************************!*\
  !*** ../../ts-observables/ComputedObservable.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluationStack\": () => (/* binding */ evaluationStack),\n/* harmony export */   \"ComputedObservable\": () => (/* binding */ ComputedObservable),\n/* harmony export */   \"co\": () => (/* binding */ co),\n/* harmony export */   \"coa\": () => (/* binding */ coa)\n/* harmony export */ });\n/* harmony import */ var _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObservableSubscription */ \"../../ts-observables/ObservableSubscription.ts\");\n/* harmony import */ var _alumis_ts_async_CancellationToken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alumis/ts-async/CancellationToken */ \"../../ts-async/CancellationToken.ts\");\n/* harmony import */ var _ModifiableObservable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModifiableObservable */ \"../../ts-observables/ModifiableObservable.ts\");\n\n\n\nlet bin = [],\n    binLength = 0;\nvar evaluationStack = [];\nclass ComputedObservable {\n  constructor() {\n    this.refresh = this.refresh.bind(this);\n    this.dispose = this.dispose.bind(this);\n    (this._subscriptionHead.next = this._subscriptionTail).previous = this._subscriptionHead;\n  }\n\n  _subscriptionHead = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n  _subscriptionTail = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n  observables = new Map();\n\n  get value() {\n    if (evaluationStack.length) {\n      let co = evaluationStack[evaluationStack.length - 1];\n      if (!co.observables.has(this)) co.observables.set(this, this.subscribeSneakInLine(co.refresh));\n    }\n\n    let errorReason = this.errorReason;\n    if (errorReason) throw errorReason;\n    return this.wrappedValue;\n  }\n\n  peek() {\n    return this.wrappedValue;\n  }\n\n  subscribe(callback) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndPrependToTail(this._subscriptionTail, callback);\n  }\n\n  subscribeInvoke(callback) {\n    callback(this.wrappedValue, undefined, this.errorReason);\n    let subscription = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndPrependToTail(this._subscriptionTail, callback);\n    return subscription;\n  }\n\n  subscribeSneakInLine(callback) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndAppendToHead(this._subscriptionHead, callback);\n  }\n\n  subscribeInvokeSneakInLine(callback) {\n    callback(this.wrappedValue, undefined, this.errorReason);\n    let subscription = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndAppendToHead(this._subscriptionHead, callback);\n    return subscription;\n  }\n\n  notifySubscribers(newValue, oldValue, errorReason) {\n    for (let node = this._subscriptionHead.next; node !== this._subscriptionTail;) {\n      let currentNode = node;\n      node = node.next;\n      currentNode.callback(newValue, oldValue, errorReason);\n    }\n  }\n\n  invalidate() {\n    let value = this.wrappedValue;\n    this.notifySubscribers(value, value);\n  }\n\n  chain(expression) {\n    let result = co(() => expression(this)),\n        dispose = result.dispose;\n\n    result.dispose = () => {\n      (result.dispose = dispose)();\n      this.dispose();\n    };\n\n    return result;\n  }\n\n  dispose() {\n    this.wrappedValue = undefined;\n    this.expression = undefined;\n    this.errorReason = undefined;\n    let observables = this.observables;\n    observables.forEach(s => {\n      s.dispose();\n    });\n    observables.clear();\n\n    for (let node = this._subscriptionHead.next; node !== this._subscriptionTail;) {\n      let currentNode = node;\n      node = node.next;\n      currentNode.recycle();\n    }\n\n    (this._subscriptionHead.next = this._subscriptionTail).previous = this._subscriptionHead;\n    if (bin.length === binLength) bin.push(this);else bin[binLength] = this;\n    ++binLength;\n  }\n\n  initialize() {\n    try {\n      evaluationStack.push(this);\n\n      try {\n        var result = this.expression();\n      } finally {\n        evaluationStack.pop();\n      }\n    } catch (e) {\n      this.setValueAndErrorAndNotifySubscribers(undefined, e);\n      return;\n    }\n\n    this.setValueAndErrorAndNotifySubscribers(result, null);\n  }\n\n  setValueAndErrorAndNotifySubscribers(value, errorReason) {\n    let oldValue = this.wrappedValue,\n        oldError = this.errorReason;\n\n    if (value !== oldValue || errorReason !== oldError) {\n      this.wrappedValue = value;\n      this.errorReason = errorReason;\n      this.notifySubscribers(value, oldValue, errorReason);\n    }\n  }\n\n  refresh() {\n    let observables = this.observables;\n    observables.forEach(s => {\n      s.dispose();\n    });\n    observables.clear();\n    this.initialize();\n  }\n\n}\nfunction co(expression) {\n  let evaluateAtOnce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (binLength) {\n    var result = bin[--binLength];\n    bin[binLength] = null;\n  } else var result = new ComputedObservable();\n\n  result.expression = expression;\n  if (evaluateAtOnce) result.initialize();\n  return result;\n}\nfunction coa(expression) {\n  let cancellationToken = new _alumis_ts_async_CancellationToken__WEBPACK_IMPORTED_MODULE_1__.CancellationToken(),\n      errorReason = (0,_ModifiableObservable__WEBPACK_IMPORTED_MODULE_2__.o)(),\n      result = (0,_ModifiableObservable__WEBPACK_IMPORTED_MODULE_2__.o)(),\n      computedObservable = co(() => {\n    let errorReasonValue = errorReason.value;\n    if (errorReasonValue) throw errorReasonValue.reason;\n    return result.value;\n  });\n  let dispose = computedObservable.dispose;\n\n  computedObservable.dispose = () => {\n    cancellationToken.cancel();\n    queueMicrotask(() => (computedObservable.dispose = dispose)());\n  };\n\n  expression(cancellationToken).then(r => result.value = r).catch(r => errorReason.value = {\n    reason: r\n  });\n  return computedObservable;\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/ComputedObservable.ts?");

/***/ }),

/***/ "../../ts-observables/ModifiableObservable.ts":
/*!****************************************************!*\
  !*** ../../ts-observables/ModifiableObservable.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ModifiableObservable\": () => (/* binding */ ModifiableObservable),\n/* harmony export */   \"o\": () => (/* binding */ o)\n/* harmony export */ });\n/* harmony import */ var _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObservableSubscription */ \"../../ts-observables/ObservableSubscription.ts\");\n/* harmony import */ var _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComputedObservable */ \"../../ts-observables/ComputedObservable.ts\");\n\n\nlet bin = [],\n    binLength = 0;\nclass ModifiableObservable {\n  constructor() {\n    this.dispose = this.dispose.bind(this);\n    (this._subscriptionHead.next = this._subscriptionTail).previous = this._subscriptionHead;\n  }\n\n  _subscriptionHead = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n  _subscriptionTail = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n\n  get value() {\n    if (_ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack.length) {\n      let co = _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack[_ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack.length - 1];\n      if (!co.observables.has(this)) co.observables.set(this, this.subscribeSneakInLine(co.refresh));\n    }\n\n    return this.wrappedValue;\n  }\n\n  set value(newValue) {\n    let oldValue = this.wrappedValue;\n\n    if (newValue !== oldValue) {\n      this.wrappedValue = newValue;\n      this.notifySubscribers(newValue, oldValue);\n    }\n  }\n\n  peek() {\n    return this.wrappedValue;\n  }\n\n  subscribe(callback) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndPrependToTail(this._subscriptionTail, callback);\n  }\n\n  subscribeInvoke(callback) {\n    callback(this.wrappedValue, undefined);\n    let subscription = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndPrependToTail(this._subscriptionTail, callback);\n    return subscription;\n  }\n\n  subscribeSneakInLine(callback) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndAppendToHead(this._subscriptionHead, callback);\n  }\n\n  subscribeInvokeSneakInLine(callback) {\n    callback(this.wrappedValue, undefined);\n    let subscription = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndAppendToHead(this._subscriptionHead, callback);\n    return subscription;\n  }\n\n  notifySubscribers(newValue, oldValue) {\n    for (let node = this._subscriptionHead.next; node !== this._subscriptionTail;) {\n      let currentNode = node;\n      if (node.next && node.next !== this._subscriptionTail && !node.next.callback) debugger;\n      node = node.next;\n      currentNode.callback(newValue, oldValue);\n    }\n  }\n\n  notifySubscribersExcept(newValue, oldValue, exemptedObservableSubscription) {\n    for (let node = this._subscriptionHead.next; node !== this._subscriptionTail;) {\n      let currentNode = node;\n      node = node.next;\n      if (currentNode !== exemptedObservableSubscription) currentNode.callback(newValue, oldValue);\n    }\n  }\n\n  setValueDontNotifySubscription(newValue, exemptedObservableSubscription) {\n    let oldValue = this.wrappedValue;\n\n    if (newValue !== oldValue) {\n      this.wrappedValue = newValue;\n      this.notifySubscribersExcept(newValue, oldValue, exemptedObservableSubscription);\n    }\n  }\n\n  invalidate() {\n    let value = this.wrappedValue;\n    this.notifySubscribers(value, value);\n  }\n\n  dispose() {\n    this.wrappedValue = null;\n\n    for (let node = this._subscriptionHead.next; node !== this._subscriptionTail;) {\n      let currentNode = node;\n      node = node.next;\n      currentNode.recycle();\n    }\n\n    (this._subscriptionHead.next = this._subscriptionTail).previous = this._subscriptionHead;\n    if (bin.length === binLength) bin.push(this);else bin[binLength] = this;\n    ++binLength;\n  }\n\n}\nfunction o(value) {\n  if (binLength) {\n    var result = bin[--binLength];\n    bin[binLength] = null;\n  } else var result = new ModifiableObservable();\n\n  result.wrappedValue = value;\n  return result;\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/ModifiableObservable.ts?");

/***/ }),

/***/ "../../ts-observables/ObservableList.ts":
/*!**********************************************!*\
  !*** ../../ts-observables/ObservableList.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObservableList\": () => (/* binding */ ObservableList),\n/* harmony export */   \"ObservableListModificationType\": () => (/* binding */ ObservableListModificationType),\n/* harmony export */   \"ObservableListRefItemNotFoundError\": () => (/* binding */ ObservableListRefItemNotFoundError)\n/* harmony export */ });\n/* harmony import */ var _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObservableSubscription */ \"../../ts-observables/ObservableSubscription.ts\");\n/* harmony import */ var _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComputedObservable */ \"../../ts-observables/ComputedObservable.ts\");\n\n\nclass ObservableList {\n  constructor(iterable) {\n    this.iterable = iterable;\n    this.dispose = this.dispose.bind(this);\n    (this._subscriptionsHead.next = this._subscriptionsTail).previous = this._subscriptionsHead;\n    (this.head.next = this.tail).previous = this.head;\n    if (iterable) for (let i of iterable) this.append(i);\n  }\n\n  head = {};\n  tail = {};\n  itemToNode = new Map();\n  _subscriptionsHead = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n  _subscriptionsTail = _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.create();\n\n  append(item) {\n    let node = this.itemToNode.get(item);\n\n    if (node) {\n      if (node.next === this.tail) return;\n      let previous = node.previous,\n          next = node.next;\n      previous.next = next;\n      next.previous = previous;\n    } else this.itemToNode.set(item, node = {\n      item: item\n    });\n\n    (node.previous = this.tail.previous).next = node;\n    (node.next = this.tail).previous = node;\n    this.notifySubscribers([{\n      type: ObservableListModificationType.Append,\n      item: item\n    }]);\n  }\n\n  appendItems(items) {\n    let modifications = [];\n\n    for (let i of items) {\n      let node = this.itemToNode.get(i);\n\n      if (node) {\n        if (node.next === this.tail) continue;\n        let previous = node.previous,\n            next = node.next;\n        previous.next = next;\n        next.previous = previous;\n      } else this.itemToNode.set(i, node = {\n        item: i\n      });\n\n      (node.previous = this.tail.previous).next = node;\n      (node.next = this.tail).previous = node;\n      modifications.push({\n        type: ObservableListModificationType.Append,\n        item: i\n      });\n    }\n\n    if (modifications.length) this.notifySubscribers(modifications);\n  }\n\n  remove(item) {\n    let node = this.itemToNode.get(item);\n\n    if (node) {\n      this.itemToNode.delete(item);\n      let previous = node.previous,\n          next = node.next;\n      previous.next = next;\n      next.previous = previous;\n      this.notifySubscribers([{\n        type: ObservableListModificationType.Remove,\n        item: item\n      }]);\n    }\n  }\n\n  removeItems(items) {\n    let modifications = [];\n\n    for (let i of items) {\n      let node = this.itemToNode.get(i);\n\n      if (node) {\n        this.itemToNode.delete(i);\n        let previous = node.previous,\n            next = node.next;\n        previous.next = next;\n        next.previous = previous;\n        modifications.push({\n          type: ObservableListModificationType.Remove,\n          item: i\n        });\n      }\n    }\n\n    if (modifications.length) this.notifySubscribers(modifications);\n  }\n\n  insertBefore(newItem, refItem) {\n    let node = this.itemToNode.get(newItem);\n\n    if (node) {\n      let previous = node.previous,\n          next = node.next;\n      previous.next = next;\n      next.previous = previous;\n    } else this.itemToNode.set(newItem, node = {\n      item: newItem\n    });\n\n    let refNode;\n\n    if (refItem !== null) {\n      refNode = this.itemToNode.get(refItem);\n      if (!refNode) throw new ObservableListRefItemNotFoundError(refItem);\n    } else refNode = this.tail;\n\n    if (refNode.previous === node) return;\n    (node.previous = refNode.previous).next = node;\n    (node.next = refNode).previous = node;\n    this.notifySubscribers([{\n      type: ObservableListModificationType.InsertBefore,\n      item: newItem,\n      refItem: refItem\n    }]);\n  }\n\n  [Symbol.iterator]() {\n    if (_ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack.length) {\n      let co = _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack[_ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.evaluationStack.length - 1];\n      if (!co.observables.has(this)) co.observables.set(this, this.subscribeSneakInLine(co.refresh));\n    }\n\n    let node = this.head;\n    return {\n      next: () => {\n        node = node.next;\n        if (node !== this.tail) return {\n          value: node.item,\n          done: false\n        };else return {\n          done: true\n        };\n      }\n    };\n  }\n\n  reconcile(items) {\n    if (!(items instanceof Set)) items = new Set(items);\n\n    for (let i of this.itemToNode.keys()) if (!items.has(i)) this.remove(i);\n\n    for (let i of items) this.append(i);\n  }\n\n  subscribe(action) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndPrependToTail(this._subscriptionsTail, action);\n  }\n\n  subscribeSneakInLine(action) {\n    return _ObservableSubscription__WEBPACK_IMPORTED_MODULE_0__.ObservableSubscription.createAndAppendToHead(this._subscriptionsHead, action);\n  }\n\n  notifySubscribers(modifications) {\n    for (let node = this._subscriptionsHead.next; node != this._subscriptionsTail;) {\n      let currentNode = node;\n      node = node.next;\n      currentNode.callback(modifications);\n    }\n  }\n\n  dispose() {\n    delete this.head;\n    delete this.tail;\n\n    for (let node = this._subscriptionsHead.next; node != this._subscriptionsTail;) {\n      let currentNode = node;\n      node = node.next;\n      currentNode.recycle();\n    }\n\n    this._subscriptionsHead.recycle();\n\n    delete this._subscriptionsHead;\n\n    this._subscriptionsTail.recycle();\n\n    delete this._subscriptionsTail;\n  }\n\n}\nlet ObservableListModificationType;\n\n(function (ObservableListModificationType) {\n  ObservableListModificationType[ObservableListModificationType[\"Append\"] = 0] = \"Append\";\n  ObservableListModificationType[ObservableListModificationType[\"InsertBefore\"] = 1] = \"InsertBefore\";\n  ObservableListModificationType[ObservableListModificationType[\"Remove\"] = 2] = \"Remove\";\n})(ObservableListModificationType || (ObservableListModificationType = {}));\n\nclass ObservableListRefItemNotFoundError extends Error {\n  constructor(refItem) {\n    super(`Referenced item '${refItem}' was not found`);\n  }\n\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/ObservableList.ts?");

/***/ }),

/***/ "../../ts-observables/ObservableSubscription.ts":
/*!******************************************************!*\
  !*** ../../ts-observables/ObservableSubscription.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObservableSubscription\": () => (/* binding */ ObservableSubscription)\n/* harmony export */ });\n// Each observable keeps a doubly-linked list of subscriptions (callbacks to invoke when a state changes).\n// It is a doubly-linked list because insertions and deletions should be fast.\n// The doubly-linked list usually has a head and a tail.\n// When a subscription is no longer needed, it should be recycled for later usage.\n// The bin immediately below keeps references to ready-to-use subscriptions that have been recycled.\nlet bin = [],\n    binLength = 0;\nclass ObservableSubscription {\n  constructor() {\n    this.dispose = this.dispose.bind(this);\n  }\n  /**\r\n   * Creates or returns a recycled instance.\r\n   * @internal\r\n   */\n\n\n  static create() {\n    if (binLength) {\n      let existing = bin[--binLength];\n      bin[binLength] = null;\n      return existing;\n    }\n\n    return new ObservableSubscription();\n  }\n  /**\r\n   * Creates and appends a new subscription to right before the tail.\r\n   * @internal\r\n   */\n\n\n  static createAndPrependToTail(tail, callback) {\n    let result = ObservableSubscription.create();\n    (result.previous = tail.previous).next = result;\n    (result.next = tail).previous = result;\n    result.callback = callback;\n    return result;\n  }\n  /**\r\n   * Creates and prepends a new subscription to right after the head.\r\n   * @internal\r\n   */\n\n\n  static createAndAppendToHead(head, callback) {\n    let result = ObservableSubscription.create();\n    (result.next = head.next).previous = result;\n    (result.previous = head).next = result;\n    result.callback = callback;\n    return result;\n  }\n\n  /**\r\n   * Recycles a subscription (places it in the bin) such that it may be reused.\r\n   * @remarks\r\n   * Use unsubscribeAndRecycle() if you instead wish to both unsubscribe and recycle.\r\n   * @internal\r\n   */\n  recycle() {\n    this.callback = undefined;\n    this.previous = undefined;\n    this.next = undefined;\n    if (bin.length === binLength) bin.push(this);else bin[binLength] = this;\n    ++binLength;\n  }\n  /**\r\n   * Use this function if you no longer wish the callback to be invoked.\r\n   * @remarks\r\n   * After invocation, for long-lived scopes, you should expunge any reference you have to it to accommodate the GC.\r\n   */\n\n\n  dispose() {\n    (this.previous.next = this.next).previous = this.previous;\n    this.previous = undefined;\n    this.next = undefined;\n    this.recycle();\n  }\n\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/ObservableSubscription.ts?");

/***/ }),

/***/ "../../ts-observables/isObservable.ts":
/*!********************************************!*\
  !*** ../../ts-observables/isObservable.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isObservable\": () => (/* binding */ isObservable)\n/* harmony export */ });\n/* harmony import */ var _ModifiableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ModifiableObservable */ \"../../ts-observables/ModifiableObservable.ts\");\n/* harmony import */ var _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComputedObservable */ \"../../ts-observables/ComputedObservable.ts\");\n/* harmony import */ var _AsyncObservable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AsyncObservable */ \"../../ts-observables/AsyncObservable.ts\");\n\n\n\nfunction isObservable(obj) {\n  return obj instanceof _ModifiableObservable__WEBPACK_IMPORTED_MODULE_0__.ModifiableObservable || obj instanceof _ComputedObservable__WEBPACK_IMPORTED_MODULE_1__.ComputedObservable || obj instanceof _AsyncObservable__WEBPACK_IMPORTED_MODULE_2__.AsyncObservable;\n}\n\n//# sourceURL=webpack://test-workspace/../../ts-observables/isObservable.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.tsx");
/******/ 	
/******/ })()
;